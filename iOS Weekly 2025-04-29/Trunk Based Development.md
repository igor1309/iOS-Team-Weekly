
**Trunk Based Development (TBD)** — это подход к разработке программного обеспечения, при котором все разработчики работают с **одной основной веткой**. Вместо создания долгоживущих веток, изменения часто коммитятся и интегрируются напрямую в основную ветку, как можно быстрее.

### **Основные характеристики Trunk Based Development:**

1. **Маленькие и частые коммиты** — изменения вносятся регулярно (несколько раз в день).
    
2. **Минимальное использование фичевых веток** — если и используются, то очень короткоживущие (несколько часов или максимум день).
    
3. **Фича-тогглы (feature toggles)** — используются для включения/отключения незавершённой функциональности без создания отдельных веток.
    
4. **Непрерывная интеграция (CI)** — автоматические проверки и сборка происходят при каждом коммите в основную ветку.
    
5. **Избежание merge hell** — так как все работают с одной веткой, конфликты минимальны и решаются быстро.


## Central Workflow

Просто комит и сразу в мастер. А ветки для слабаков.

![Цепочка комитов в master-ветку](https://habrastorage.org/r/w1560/getpro/habr/upload_files/7e6/a18/ad1/7e6a18ad1d174aed3dfb716e235709b6.png "Цепочка комитов в master-ветку")

Цепочка комитов в master-ветку

В итоге Central Workflow подходит:

- Для небольших проектов (pet-проектов).
        
- Когда мастер сломан.
    

## Git Flow

Процесс — это все! Сложный процесс со сложной моделью ветвления. 

![Так выглядит этот процесс у автора https://nvie.com/posts/a-successful-git-branching-mode](https://habrastorage.org/r/w1560/getpro/habr/upload_files/0dc/e50/cfb/0dce50cfbdd50758e8e046429a77fd8c.png "Так выглядит этот процесс у автора https://nvie.com/posts/a-successful-git-branching-mode")


Чтобы было проще, постараюсь изложить процесс в виде цикла разработки фичи:

![Исходное состояние](https://habrastorage.org/r/w1560/getpro/habr/upload_files/31c/232/685/31c2326851c08789bfb539d0f8eb43e8.png "Исходное состояние")

Исходное состояние

Для создания фичи, вы создаете ветку **_feature_**. Ветвите вы её от ветки **_develop:_**

![Сделали ветку feature, в которой будет вестись разработка](https://habrastorage.org/r/w1560/getpro/habr/upload_files/1be/cbe/fef/1becbefef816ee9453d5a0544fd60cba.png "Сделали ветку feature, в которой будет вестись разработка")

Сделали ветку feature, в которой будет вестись разработка

Ветка создана, можно начинать разработку.

![Вы поработали, сделали несколько комитов](https://habrastorage.org/r/w1560/getpro/habr/upload_files/105/41e/6fc/10541e6fc2ecf4c35cc8cf612a2bc9b8.png "Вы поработали, сделали несколько комитов")

Вы поработали, сделали несколько комитов

Ваша команда долго и упорно готовила фичу — теперь всё готово! Но другие команды разработки тоже делают свои проекты. Допустим, готовые фичи уже слили в **_develop_**-ветку, при этом ваша ветка сильно отстала.

**[Первый раз]** Вы решаете конфликты и сливаете ветку в develop:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/fec/01a/862/fec01a8628f06ef798cd331601d4caef.png)

Время релиза! Вы решили поделится своей фичей с пользователями. Создаётся ветка **_release_** от вашего комита.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/4fc/c84/44c/4fcc8444c1e46e098f305d43d33435bf.png)

Но релиз нужно стабилизировать. В нем есть баги, и конфликтующие фичи. Для этого делаем несколько hotfix. Важно, что делаем мы их в релиз-ветке, потому что планируем выкатить именно её.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/e1f/006/8b1/e1f0068b1cc388b2be74797088924ab4.png)

Релиз стабилизирован. Сливаем его в master c тегом v1.0.0 и катим на prod. Хотфиксы тоже надо слить в develop-ветку. За это время develop опять ушёл вперед.

**[Второй раз]** Вы решаете конфликты и сливаете ветку в develop:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/885/e02/609/885e02609d7781a2cc8d81d1b9b819b2.png)

На prod мы неожиданно ловим еще несколько ошибок, которые важно пофиксить. Вы делаете хотфикс на prod и ветку v1.0.1.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/713/2c5/0cc/7132c50cc1c8011743efb16669f5ed65.png)

Но новый хотфикс тоже нужно положить обратно в develop-ветку. За это время develop опять ушёл вперед.

**[Третий раз]** Вы решаете конфликты и сливаете ветку в develop:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/200/74d/e36/20074de36fac62ddffbab154e1bc331c.png)

В итоге Git Flow:

- Очень сложно и запутано.
    
- Много конфликтов в процессе.
    
- Долгий релизный цикл, который плохо подходит для CI\CD.
    
- Подходит для ПО с классическим релейным циклом (параллельная работа над разными версиями, релиз раз в месяц на дискетах).
    

## Trunk Based Development

![trunkbaseddevelopment.com](https://habrastorage.org/r/w1560/getpro/habr/upload_files/025/94e/5fd/02594e5fde4678af4e5b579f6452aa82.png "trunkbaseddevelopment.com")

trunkbaseddevelopment.com

Характеризуется всего тремя типами веток и итеративным подходом к разработке фичи (привет, Scrum). 

Постараюсь изложить его в виде цикла разработки фичи:

![Исходное состояние](https://habrastorage.org/r/w1560/getpro/habr/upload_files/07d/371/b39/07d371b39c5ebf031f1d7c8844996639.png "Исходное состояние")

Исходное состояние

Для создания фичи, вы создаете ветку **_feature_**. Ветвите вы её от ветки **_master:_**

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/108/866/373/108866373a258062495e9828a0af5f18.png)

Делаете несколько комитов, заглушки под фичу и необходимые интерфейсы:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/32e/7b2/5ad/32e7b25ade073ebc989aea73edeac86d.png)

Сливаете **_фича-ветку_** в **_master_**. Ваш функционал может быть закрыт **_feature-toggle_** или `if false { ... }` — «сырой» функционал не должен быть доступен пользователю.

Важно!

Так как с момента ветвления до момента слияния вашей фича-ветки прошло очень мало времени, master не успеет далеко уйти и у вас будет минимум или полное отсутствие конфликтов при слиянии. При этом вы «застолбили» для своей фичи место, подсветили другим командам, к примеру, интерфейсы, которые планируете имплементить. И другие команды будут сразу учитывать это в своей работе.

А ещё у вас очень маленькие PR\MR, которым можно легко и быстро провести code-review. Знаете же эту классическую проблему — большие PR смотрят долго и некачественно.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/299/6f7/f74/2996f7f74e5ceb163a5136447079a1fa.png)

У вас может быть организован процесс непрерывного деплоя, или деплоя по расписанию, в prod. Так как в master не сливают сложные и плохо протестированные изменения — master остаётся чистым, готовым к релизам.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/7e3/b16/2fc/7e3b162fc54cebd80fd8c38e6411b164.png)

Вы продолжаете работать над своей фичей в новой итерации — продолжаете её и углубляете. 

Важно, чтобы ваша новая фича-ветка оказалось очень короткоживущей, чтобы ловить минимум конфликтов при слиянии и углубить создание фичи.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/d74/9e5/062/d749e50628591f633a17d4c485970123.png)

### В итоге, TBD — это:

- Ветки, которые живут несколько дней.
    
- Feature-flags для закрытия «сырого» функционала.
    
- Continuous Сode Review. Код-ревью фича проходит каждую итерацию — дифф маленький, ревью делается быстро.
    
- Чистый мастер, готовый к релизу в любой момент.
    

### Плюсы TBD:

- Минимум конфликтов при разработке.
    
- Готовность к релизам в любой момент без подготовки.
    
- Очень быстрая и качественная обратная связь на PR\MR.
    

### Минусы TBD:

- Не подходит, если в команде много junior-разработчиков. Ребятам гораздо легче делать\ревьювить готовую фичу целиком, чем разделить работу на этапы и держать прошлые итерации в голове.
    
- Нужно доверять комитерам, иначе будут висеть недоделанные фичи и будет непонятно, кто и когда их доделает.
    
- Если потребуется revert — будет больно. Мастер постоянно бежит вперед и revert функционал спустя пару дней уже тяжело. Проще исправить или удалить руками.
    

### Кому подходит TBD:

- Опытным командам с небольшим количеством junior-разработчиков.
    
- Большим командам, которые параллельно работают над большим количеством фич.
    
- Приложениям с долгим циклом регрессивного тестирования.
    
- Проектам с непрерывным релизным циклом.
    

### Для кого TBD не очень хорошо подходит:

- Junior-командам.
    
- OpenSource-проектам.
    
- Проектам с жестким (классическим) релизным циклом с отгрузкой софта клиентам на дискетах.



### **2.** 

### **GitHub Flow**

- **Структура:** Только main и короткие фичевые ветки, PR-ориентированный процесс.
    
- **Подходит для:** Open Source и небольших команд.
    
- **Плюсы:**
    
    - Простота.
        
    - Хорошо интегрируется с GitHub Actions.
        
    
- **Минусы:**
    
    - Сложно масштабировать на большие команды без дисциплины.
        
    - Требует зрелого CI.



###  **3.** 

### **GitLab Flow**

- **Гибрид Git Flow + TBD:** Поддержка нескольких окружений (staging, production), с фокусом на CI/CD.
    
- **Плюсы:**
    
    - Гибкость.
        
    - Поддержка release-тегов и environment-веток.
        
    
- **Минусы:**
    
    - Может быть сложно настроить и поддерживать.
        
    - Чуть сложнее, чем GitHub Flow.



| **Workflow**      | **Скорость релизов** | **Простота** | **Масштабируемость** | **CI/CD-дружелюбие** |
| ----------------- | -------------------- | ------------ | -------------------- | -------------------- |
| Trunk Based Dev   | 🟢 ⭐️Очень высокая   | 🟡 Средняя   | 🟢 Высокая           | 🟢 ⭐️Отличная        |
| Git Flow          | 🔴 Низкая            | 🔴 Сложная   | 🟡 Средняя           | 🔴 Плохая            |
| GitHub Flow       | 🟢 Высокая           | 🟢 Простая   | 🟡 Средняя           | 🟢 Хорошая           |
| GitLab Flow       | 🟡 Средняя           | 🟡 Средняя   | 🟢 Хорошая           | 🟢 Хорошая           |
| Release Branching | 🔴 Низкая            | 🟡 Средняя   | 🟡 Средняя           | 🔴 Плохая            |



### Кто и почему использует TBD

Многие крупные технологические компании используют **Trunk-Based Development (TBD)** из-за его способности ускорять выпуск продуктов, повышать стабильность кода и упростить CI/CD. Вот некоторые известные примеры:
### **Google**

- **Почему:** У Google монорепозиторий с миллионами строк кода и десятками тысяч инженеров. TBD позволяет всем работать в одном «тронке», обеспечивая высокую частоту изменений и автоматическое тестирование.
    
- **Результат:** Частые, безопасные релизы и централизованное управление качеством


### **Facebook**

- **Почему:** Требуется быстро выпускать новые функции и проводить A/B тесты. TBD с фича-флагами позволяет выкатывать незавершённый код в прод без риска.
    
- **Результат:** Непрерывные обновления и гибкость для product-экспериментов.

### **Яндекс**

- В больших сервисах, таких как **Поиск**, **Яндекс.Браузер**, **Яндекс.Драйв** и **Яндекс Go**, команды часто придерживаются **короткоживущих фич-веток**, быстро вливаемых в main или develop.
    
- Принята культура **частых релизов**, что требует отлаженной автоматической сборки и тестирования — классические атрибуты TBD.
    
- Используются **фича-флаги**, **автоматические проверки на пулл-реквестах** и **развертывание по графику**, что тоже хорошо сочетается с TBD.

**Почему TBD подходит Яндексу:**

- Много параллельно работающих команд.
- Продукты с микросервисной архитектурой.
- Высокие требования к стабильности при частых изменениях.
- Быстрая проверка гипотез, особенно в мобильных и веб-продуктах.
### **Почему компании выбирают TBD:**

- 📦 Быстрый time-to-market.
- ✅ Меньше merge-конфликтов.
- 🔁 Высокий уровень автоматизации CI/CD.
- 🧪 Простота внедрения A/B тестирования.
- 🔒 Более стабильный и проверенный код на main.

Материалы:

https://trunkbaseddevelopment.com/release-from-trunk/
https://habr.com/ru/companies/avito/articles/680522/

[[Trunk Based Development]] , [[TBD]]
#trunk_based_development
